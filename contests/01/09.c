//-------------- PROBLEM 01-09 --------------//
//       https://t.me/hse_walkthrough        //
//---------------- Editorial ----------------//
//Для решения задачи переберем все побитовые //
//сдивиги числа N, после чего извлечем из    //
//из полученных чисел 1 последний бит и      //
//посчитаем их сумму.                        //
//Примечание: задача подсчета единичных битов//
//является очень часто встречающейся.        //
//На самом деле, это требуется настолько     //
//часто, что люди даже придумали отдельную   //
//инструкцию процессора, подсчитывающую      //
//количество единичных битов в машинном слове//
//Эта инструкция - POPCNT, доступна в SSE4,  //
//так что её можно использовать на           //
//большинстве современных процессоров. В     //
//языке си, чтобы вызвать её, достаточно     //
//написать __builtin_popcount(n)             //
//вызов этой функции вернет количество       //
//единичных бит в числе n, причем достаточно //
//быстро.                                    //
//В системах, не поддерживающих такие        //
//инструкции, тоже есть способ быстрого      //
//подсчета количетва единичных битов в числе //
//На Хабре есть хорошая статья об этом:      //
//https://habr.com/ru/articles/276957/       //
//-------------------------------------------//

//Подключение требуемых библиотек
#include <stdio.h>

//Функция, возвращающая число, в котором в K младших разрядах - единица, а в остальных - ноль
unsigned int kOnes(unsigned int k) {
    return 0xffffffff >> (32 - k);
}

int main(void)
{
    unsigned int n; //Заводим переменную для пользовательского ввода
    scanf("%u", &n); //Считываем N, K
    unsigned int sum = 0; //Заведем переменную для ответа
    do { //Будем "откусывать" по одному биту числа, и смотреть его последний бит
        sum += (n & 1);
    }
    while (n >>= 1); //"Откусываем" последний бит числа, выходим из цикла, если число = 0
    printf("%u\n", sum); //Выводим ответ
    return 0; //Корректно завершаем работу программы
}
