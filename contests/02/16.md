
# Задача 16 (Не пара 3)
Для решения задачи, воспользуемся методом **bucketing** (разделения), а также текстом решения [задачи 15 [ССЫЛКА]](https://github.com/hse-du/hse-walkthrough/blob/main/contests/02/15.md)

Убедитесь, что понимаете решение этой задачи, прежде чем переходить к этой.

Пусть искомые числа = `a`, `b`, `c`. Три этих числа различны (по условию)

Заметим, что если мы каким-то образом узнаем одно из этих чисел(допустим, `c`), для решения задачи достаточно будет добавить это число в последовательность, после чего задача будет сведена к 15-ой, решение которой мы уже знаем.

Добавить число в последовательность можно так:
```c
int n = ...; //Количество чисел
int numbers[] = {...}; //n чисел и одно любое дополнительное
int c = ...; //Найденное c

numbers[n++] = c; //Добавляем c
```

Так, мы свели нашу задачу к задаче выделения хотя бы одного числа из последовательности.

Чтобы выделить хотя бы одно число, снова воспользуемся методом bucketing.
На этот раз, нам нужна такая функция `f(x)` с областью значений `{0, 1}`, чтобы **не выполнялось** `f(a) == f(b) == f(c)`. Тогда, поместим число x в `f(x)`-й bucket таким же способом, как и в первой задаче.
Заметим, что после обработки всей последовательности в одном из bucket-ов будет лежать искомое `c`(или, `a`, или `b`, мы просто предполагаем, что оно `c`, порядок не важен), а в другом - `a XOR b`(или, `b XOR c`, или `a XOR c`, мы просто предполагаем, что оно `a XOR b`, порядок не важен)

Чтобы понять, в каком bucket-е лежит единственное число, нам придется проверить, встречается ли число в первом bucket-е единственный раз в последовательности. Если это так, в нем лежит искомое `c`, иначе, искомое `c` находится в другом bucket-е.

Мы можем сделать это так:
```c
int n = ...; //Количество чисел
int numbers[] = {...}; //Числа
int bucket0 = ...; //Значение 1-го bucket-а
int bucket1 = ...; //Значение 2-го bucket-а
int counter = 0;
for(int i = 0; i < n; i++)
    if (numbers[i] == bucket0)
        counter++;

int c; //Искомое c
//Если число bucket0 встречается
//в последовательности единственный раз
if (counter == 1) 
    c = bucket0; //Оно и есть искомое с
else //Иначе, мы не угадали
    c = bucket1; //c лежит в другом bucket-е
```

Для решения задачи, осталось найти такое f(x), что `f(a)==f(b)==f(c)` - **неверно**

Рассмотрим XOR всех чисел = `s`.

Введем дополнительную функцию, возвращающую число, представляющее собой `1` на позиции самого старшего ненулевого бита числа `x`
(Она же - функция, возвращающая набольшую степень двойки < x)

Вот она:
```c
int highest_p2(int x) {
    int m = 1;
    while ((m & x) != x)
        m = (m << 1) | 1;
    return m - (m >> 1);
}
```

После чего, найдем XOR всех значений `highest_p2(s ^ a[n])`, пусть, это число = `k`

Заметим следующее:

Для всех одинаковых чисел `d==d`, `s^d==s^d`, `highest_p2(s^d)==highest_p2(s^d)`. Тогда, такие числа `d` никак не повлияют на `k`

Тогда, `k` = `highest_p2(s^a)^highest_p2(s^b)^highest_p2(s^c)`

`s^a`=`a^b^c^a`=`b^c` = биты, в которых отличаются `b` и `c`

`s^b`=`a^b^c^b`=`a^c` = биты, в которых отличаются `a` и `c`

`s^c`=`a^b^c^c`=`a^b` = биты, в которых отличаются `a` и `b`

Найдется такой старший бит, который отличен у `a`, `b`, `c`, ведь `a != b != c`. При этом, у всех трех чисел из `a`, `b`, `c` он не может отличаться по принципу Дирихле (у нас всего два значения бита `0`, и `1`, три различающихся бита невозможны)
Тогда `k` = бит, в котором одно из чисел из `{a, b, c}` отличается от двух других.

Для решения задачи, осталось заметить, что значение этого бита в числе и есть искомая функция `f`, ведь `f(a) == f(b) == f(c)` - **неверно** (Мы доказали это в утверждении выше)

Тогда, определим функцию `f`, зная `k`
```
int f(int x) {
    if (k & x) == 0)
        return 0;
    else
        return 1;
}
```

Задача решена.