
# Задача 15 (Не пара 2)
Для решения задачи, воспользуемся методом **bucketing** (разделения).

Что такое метод разделения?
Метод разделения - метод, позволяющий выделять уникальные образцы данных, если мы смогли найти какую-то характеристику, по которой эти образцы различаются. Разделение будем производить при помощи bucket-ов - особых переменных/структур данных, позволяющих выделить искомые значения.

Пусть искомые числа = `a`, `b` и существует функция f(x), такая, что `f(a)` != `f(b)`
Допустим, `f` имеет область значений `{0, 1}` (То есть все её значения равны либо 0, либо 1)
Тогда положим число `x` в `f(x)`-й bucket.
Заметим, что все совпадающие числа попадут в один bucket, а искомые числа `a`, `b` - в разные.

Для выделения значений `a`, `b` осталось лишь найти XOR всех чисел в bucket-ах. Тогда все одинаковые числа обратятся в ноль (Выполняется `X XOR X = 0` для каждого их бита), а в bucket-ах останутся сами числа `a` и `b`.

Для экономии времени и памяти не будем хранить bucket-ы явно, как массивы и вместо этого представим их в виде двух переменных, к которым поочередно будем при-XOR-ивать очередные числа. Тогда в конце работы алгоритма в этих bucket-ах и останутся искомые числа.

Вот пример как это можно сделать:

```c
int n = ...; //<-- Количество чисел
int numbers[] = {...}; //<-- Числа
int bucket0 = 0, bucket1 = 0; //<-- Bucket-ы
for(int i = 0; i < n; i++)
    if (f(numbers[i]) == 0)
        bucket0 ^= numbers[i];
    else
        bucket1 ^= numbers[i];
//Теперь в bucket0 и bucket1 лежат искомые a, b
```

Осталось лишь найти такую функцию-характеристику `f`, с областью значений `{0, 1}`, что `f(a) != f(b)`

Для этого рассмотрим XOR всех чисел последовательности
Все числа кроме искомых в этой последовательности встречаются ровно два раза (то есть их попарный XOR будет равен нулю).
Остальные же два числа встречаются по одному разу.
Тогда, XOR всех чисел последовательности = `a xor b`

Заметим, что `a != b`, ведь каждое число встречается строго один раз. Тогда в двоичном представлении этих чисел будет хотя бы один отличающийся бит (то есть `(a xor b) != 0`), ведь XOR двух бит равен 1 тогда и только тогда, когда эти биты отличаются.
Найдем любой единичный бит `a xor b`, например вот так:
```c
int any_bit(int x) {
    for(int i = 0; i < 31; i++)
        if ((x & (1 << i)) != 0)
            return i;
}
```

Увидим, что в случае, когда бит `a xor b` равен 1, соответствущие биты `a` и `b` отличаются (ведь при равных битах xor = 0)

Для решения задачи, осталось заметить, что значение этого бита в числе и есть искомая функция `f`, ведь `f(a) != f(b)` (Мы доказали это в утверждении выше)

Тогда, определим функцию `f`, зная, что xor всех чисел последовательности = `s`

```c
int f(int x) {
    if (((1 << any_bit(s)) & x) == 0)
        return 0;
    else
        return 1;
}
```

Задача решена.